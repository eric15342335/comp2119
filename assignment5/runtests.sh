#!/bin/bash

# COMP2119 Assignment 5 Automatic Testing Script
# Tasks: A, B, C
# Author: Eric15342335 and o1-mini
# Date: 2024/Nov/30

UniversityNumber=3036216734

# Color codes for better message distinction
GREEN='\033[1;32m'
RED='\033[1;31m'
YELLOW='\033[1;33m'
BLUE='\033[1;34m'
NC='\033[0m' # No Color

# Function to print messages with color and prefix
print_message() {
    local type="$1"
    local message="$2"
    case "$type" in
        INFO)
            echo -e "${BLUE}[INFO]${NC} $message"
            ;;
        SUCCESS)
            echo -e "${GREEN}[SUCCESS]${NC} $message"
            ;;
        WARNING)
            echo -e "${YELLOW}[WARNING]${NC} $message"
            ;;
        ERROR)
            echo -e "${RED}[ERROR]${NC} $message"
            ;;
        TIME)
            echo -e "${YELLOW}[TIME]${NC} $message"
            ;;
        *)
            echo "[UNKNOWN] $message"
            ;;
    esac
}

# Function to determine the executable suffix based on the operating system
get_exe_suffix() {
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo ""
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        echo ""  # macOS also uses no suffix
    elif [[ "$OSTYPE" == "msys"* ]] || [[ "$OSTYPE" == "cygwin"* ]]; then
        echo ".exe"
    else
        echo ""
    fi
}

# Get the executable suffix
exe_suffix=$(get_exe_suffix)

# Define the list of tasks
tasks=("A" "B" "C")

# Define the number of test cases per task
num_test_cases=3  # Assuming 3 test cases per task (A-1 to A-3, etc.)

# Base directory for test cases
base_dir="PA2_samples"

# Initialize score variables
declare -A task_scores
total_score=0
max_total_score=0
points_per_test=1  # Points per successful test case

# Determine the external 'time' command
if command -v /usr/bin/time &> /dev/null; then
    TIME_CMD="/usr/bin/time"
elif command -v /bin/time &> /dev/null; then
    TIME_CMD="/bin/time"
else
    TIME_CMD="time"  # Fallback to whatever 'time' is in PATH
fi

# Check if 'timeout' command is available
if ! command -v timeout &> /dev/null; then
    print_message ERROR "'timeout' command not found. Please install it to proceed."
    exit 1
fi

# Function to clean up temporary files
cleanup() {
    rm -f compile_errors.log
    rm -f runtime_errors.log
    rm -f time.log
}
trap cleanup EXIT

# Loop through each task
for task in "${tasks[@]}"
do
    print_message INFO "=============================="
    print_message INFO "Processing Task $task"
    print_message INFO "=============================="

    # Initialize score for the current task
    task_score=0

    # Define the source file and executable name
    source_file="$UniversityNumber-$task.cpp"
    executable="${task}${exe_suffix}"

    # Compile the C++ source file
    print_message INFO "Compiling $source_file ..."

    # Automatically use sanitizers on Linux
    sanitizers=""
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        sanitizers="-fsanitize=address -fsanitize=undefined -fsanitize=leak"
    fi

    if g++ -pedantic-errors -std=c++14 -Wall -Wextra -g $sanitizers -o "$executable" "$source_file" 2> compile_errors.log; then
        print_message SUCCESS "Compilation successful for Task $task."
    else
        print_message ERROR "Compilation failed for Task $task. Skipping tests for this task."
        print_message ERROR "Compilation Errors:"
        cat compile_errors.log
        continue
    fi

    # Define the input and output directory for the current task
    input_dir="$base_dir/$task"
    output_dir="$input_dir"  # Assuming output files are in the same directory

    # Loop through each test case
    for case_num in $(seq 1 $num_test_cases)
    do
        print_message INFO "-----"
        print_message INFO "Running Test Case $task-$case_num"
        print_message INFO "Input File: $input_dir/sample$task$case_num.in"
        print_message INFO "Expected Output File: $input_dir/sample$task$case_num.ans"

        # Define input and expected output files
        input_file="$input_dir/sample$task$case_num.in"
        expected_output="$input_dir/sample$task$case_num.ans"

        # Define the output file generated by the executable
        my_output="myoutput${task}_${case_num}.txt"

        # Check if input and expected output files exist
        if [ ! -f "$input_file" ]; then
            print_message WARNING "Input file $input_file not found. Skipping Test Case $task-$case_num."
            continue
        fi

        if [ ! -f "$expected_output" ]; then
            print_message WARNING "Expected output file $expected_output not found. Skipping Test Case $task-$case_num."
            continue
        fi

        # Running command with timing
        print_message INFO "Executing: ./$executable < $input_file > $my_output"

        # Run the executable with 'time' and 'timeout'
        # Capture 'time' output into time.log
        # Redirect program's stderr to runtime_errors.log
        # 'timeout' returns:
        #   124 if command times out
        #   137 if killed by SIGKILL (e.g., after timeout)
        #   139 if segmentation fault (SIGSEGV)
        #   0 if success
        "$TIME_CMD" -f "real %e user %U sys %S" timeout 5 ./"$executable" < "$input_file" > "$my_output"

        exit_code=$?

        # Check the exit code
        if [ $exit_code -eq 124 ]; then
            print_message ERROR "Test Case $task-$case_num timed out after 5 seconds."
            print_message TIME "Execution Time: >5s"
            continue
        elif [ $exit_code -eq 139 ]; then
            print_message ERROR "Test Case $task-$case_num resulted in a Segmentation Fault."
        elif [ $exit_code -ne 0 ]; then
            print_message ERROR "Test Case $task-$case_num failed with exit code $exit_code."
        fi

        # If the program crashed or timed out, skip output comparison
        if [ $exit_code -ne 0 ] && [ $exit_code -ne 139 ] && [ $exit_code -ne 124 ]; then
            continue
        fi

        # Compare the generated output with the expected output
        if diff -w "$my_output" "$expected_output" > /dev/null; then
            print_message SUCCESS "Result: PASS"
            task_score=$((task_score + points_per_test))
        else
            print_message ERROR "Result: FAIL"
            print_message ERROR "Differences:"
            diff -w "$my_output" "$expected_output" | sed "s/^/- /"
        fi

        echo ""
    done

    # Assign and display the score for the current task
    task_scores["$task"]=$task_score
    print_message INFO "Score for Task $task: ${task_scores[$task]}/$((num_test_cases * points_per_test))"
    total_score=$((total_score + task_scores[$task]))
    max_total_score=$((max_total_score + num_test_cases * points_per_test))

    # Remove the executable after testing
    rm -f "$executable"
    print_message INFO "Completed testing for Task $task."
    echo ""

    # Cleanup all generated output files
    print_message INFO "Cleaning up generated output files..."
    rm -f myoutput*.txt
    print_message INFO "Cleanup complete."
done

# Display the final scores
print_message INFO "=============================="
print_message INFO "Final Score Summary"
print_message INFO "=============================="

for task in "${tasks[@]}"
do
    echo -e "${GREEN}Task $task: ${task_scores[$task]}/$((num_test_cases * points_per_test))${NC}"
done

echo -e "${GREEN}Total Score: $total_score/$max_total_score${NC}"

echo ""
print_message SUCCESS "All tasks have been processed."
